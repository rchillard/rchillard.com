{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019/11/09-bash-helper-scripts/","webpackCompilationHash":"c3113005095ffe160bef","result":{"data":{"markdownRemark":{"html":"<p>Returning from a long break, I thought I'd try something totally new.  I've long been looking for a way to programmatically rebuild my laptop, so I can nuke it whenever I feel like, run a set of scripts, and have a fresh and clean operating system reloaded for me.  Since I've started using Ubuntu on my laptop, it's felt like I've been bashing my head against a wall.  Terrible joke, sorry.</p>\n<p>Today, I'm using a few bash helper functions and different techniques to make my new Linux life easier.  </p>\n<h2>Technicolor Terminal Output</h2>\n<p>In bash, I've found myself writing scripts and wrestling with echo, different flags, and in-line color codes to try and make output prettier, colorful, and easier to read.  I realized I was doing a bunch of extra work and that a simple helper function could solve this problem for me.  I went to the internet, found a few examples, and I've mashed them together into something concise and easy to use:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Color in command line messaging function</span>\n<span class=\"token builtin class-name\">read</span> -r error success warning notify nocolor <span class=\"token operator\">&lt;&lt;&lt;</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[1;31m\"</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[1;32m\"</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[1;33m\"</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[1;34m\"</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[0m\"</span><span class=\"token variable\">)</span></span>\n<span class=\"token function-name function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token assign-left variable\">msg</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$2</span>\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> -e <span class=\"token string\">\"<span class=\"token variable\">${<span class=\"token operator\">!</span>1}</span><span class=\"token variable\">$1</span>:<span class=\"token variable\">${nocolor}</span> <span class=\"token variable\">$2</span>\"</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span><span class=\"token file-descriptor important\">&amp;2</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># Examples</span>\nmessage error <span class=\"token string\">\"You smashed your brain with some bash.\"</span>\nmessage success <span class=\"token string\">\"Leveled up to hero in a bash shell!\"</span>\nmessage warning <span class=\"token string\">\"Writing bash can get addictive.\"</span>\nmessage notify <span class=\"token string\">\"You're in a bash script!\"</span>\nmessage nocolor <span class=\"token string\">\"Plain old boring echo.\"</span></code></pre></div>\n<p>Copy and paste this function locally to try it out.  You'll see that you can now call the message function, giving it a type, and then a string, and you'll get color coded output in your terminal.  When writing long, involved bash scripts, this is really key, because it's easier to see your script's output and differentiate it from other programs and scripts your script has called, which may still be outputting to the terminal.</p>\n<h2>Program Dependency Check</h2>\n<p>You'll often use bash scripts to call other programs you've already installed on your machine.  Handling errors when programs haven't been installed can be a pain, so this really simple shell script (brazenly stolen from a friend) allows you to guard against missing dependencies by requiring the user to run them before proceeding.  It's simple and straightforward.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token function\">which</span> jq <span class=\"token operator\">>></span> /dev/null\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> -eq <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  message error <span class=\"token string\">\"Program required: jq\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span></code></pre></div>\n<p>In this example, this script will check to see if the program 'jq' has been installed by checking if there's a valid executable path for it, using the 'which' command.  If there is not a path, then the entire script will exit, preventing any commands below this from running.</p>\n<h2>Script Privilege Check</h2>\n<p>In a similar vein, you may also write bash scripts that are modifying system files.  It's generally a bad practice to have your script assume super user (sudo) access, so this simple block will test for root privileges and then close the script if the user isn't running it as sudo.  This is a great guard clause or if statement to add to any script that needs super user privileges.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token environment constant\">$EUID</span>\"</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  message notify <span class=\"token string\">\"Please assume root privileges\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span></code></pre></div>\n<p>If the script isn't run with root, it warns the user and exits.  Simple, straight forward, elegant.</p>\n<h2>Key-Value Pairs</h2>\n<p>One of the things about programming in bash that I miss is not having access to is an object model.  You're not going to recreate objects in bash and you really shouldn't even try.  However, you won't get far before you realize you at least need a basic key-value pair style data structure.  Luckily, bash does support associative arrays, which you can use to associate a key with a value.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Associative array of software names and their URLS to get version information from</span>\n<span class=\"token builtin class-name\">declare</span> -A downloads\n<span class=\"token assign-left variable\">downloads</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"firefox\"</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>https://product-details.mozilla.org/1.0/devedition.json \n           <span class=\"token punctuation\">[</span><span class=\"token string\">\"terraform\"</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>https://releases.hashicorp.com/index.json\n           <span class=\"token punctuation\">[</span><span class=\"token string\">\"packer\"</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>https://releases.hashicorp.com/index.json\n           <span class=\"token punctuation\">[</span><span class=\"token string\">\"vscodium\"</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>https://api.github.com/repos/VSCodium/vscodium/releases/latest\n          <span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Example reference</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">${downloads<span class=\"token punctuation\">[</span>\"firefox\"<span class=\"token punctuation\">]</span>}</span>\n<span class=\"token comment\"># https://product-details.mozilla.org/1.0/devedition.json</span></code></pre></div>\n<p>Using this kind of data structure, you can loop through a set of keys and, for example, download from the URLs set as each of their values.</p>\n<h2>Conclusion</h2>\n<p>Once you add some basic window dressing to bash, I have found it much easier to do complex tasks like automating software installation.  Combining basic functions and techniques covering easy output messaging, checking for program dependencies, validating root user privileges, and using associative arrays, I have found bash extremely functional.</p>","timeToRead":3,"frontmatter":{"title":"Bash Helper Scripts","date":"November 09, 2019","tags":["productivity"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019/11/09-bash-helper-scripts/","prev":"/2019/01/18-power-over-distraction/","next":"/2019/11/10-install-firefox-developer-edition-using-bash/"}}}